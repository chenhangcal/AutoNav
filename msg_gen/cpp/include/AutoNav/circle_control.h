/* Auto-generated by genmsg_cpp for file /home/dev/ros/stacks/AutoNav/msg/circle_control.msg */
#ifndef AUTONAV_MESSAGE_CIRCLE_CONTROL_H
#define AUTONAV_MESSAGE_CIRCLE_CONTROL_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"


namespace AutoNav
{
template <class ContainerAllocator>
struct circle_control_ {
  typedef circle_control_<ContainerAllocator> Type;

  circle_control_()
  : yaw(0.0)
  , goalX(0.0)
  , goalY(0.0)
  , errorX(0.0)
  , errorY(0.0)
  , PerrorX(0.0)
  , PerrorY(0.0)
  , PvelX(0.0)
  , PvelY(0.0)
  , VerrX(0.0)
  , VerrY(0.0)
  , VerrA(0.0)
  , CTgainP(0.0)
  , CTgainD(0.0)
  , ATgainP(0.0)
  , ATgainI(0.0)
  , ANGgainP(0.0)
  , ANGgainD(0.0)
  {
  }

  circle_control_(const ContainerAllocator& _alloc)
  : yaw(0.0)
  , goalX(0.0)
  , goalY(0.0)
  , errorX(0.0)
  , errorY(0.0)
  , PerrorX(0.0)
  , PerrorY(0.0)
  , PvelX(0.0)
  , PvelY(0.0)
  , VerrX(0.0)
  , VerrY(0.0)
  , VerrA(0.0)
  , CTgainP(0.0)
  , CTgainD(0.0)
  , ATgainP(0.0)
  , ATgainI(0.0)
  , ANGgainP(0.0)
  , ANGgainD(0.0)
  {
  }

  typedef float _yaw_type;
  float yaw;

  typedef float _goalX_type;
  float goalX;

  typedef float _goalY_type;
  float goalY;

  typedef float _errorX_type;
  float errorX;

  typedef float _errorY_type;
  float errorY;

  typedef float _PerrorX_type;
  float PerrorX;

  typedef float _PerrorY_type;
  float PerrorY;

  typedef float _PvelX_type;
  float PvelX;

  typedef float _PvelY_type;
  float PvelY;

  typedef float _VerrX_type;
  float VerrX;

  typedef float _VerrY_type;
  float VerrY;

  typedef float _VerrA_type;
  float VerrA;

  typedef float _CTgainP_type;
  float CTgainP;

  typedef float _CTgainD_type;
  float CTgainD;

  typedef float _ATgainP_type;
  float ATgainP;

  typedef float _ATgainI_type;
  float ATgainI;

  typedef float _ANGgainP_type;
  float ANGgainP;

  typedef float _ANGgainD_type;
  float ANGgainD;


  typedef boost::shared_ptr< ::AutoNav::circle_control_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::AutoNav::circle_control_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct circle_control
typedef  ::AutoNav::circle_control_<std::allocator<void> > circle_control;

typedef boost::shared_ptr< ::AutoNav::circle_control> circle_controlPtr;
typedef boost::shared_ptr< ::AutoNav::circle_control const> circle_controlConstPtr;


template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const  ::AutoNav::circle_control_<ContainerAllocator> & v)
{
  ros::message_operations::Printer< ::AutoNav::circle_control_<ContainerAllocator> >::stream(s, "", v);
  return s;}

} // namespace AutoNav

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::AutoNav::circle_control_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::AutoNav::circle_control_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::AutoNav::circle_control_<ContainerAllocator> > {
  static const char* value() 
  {
    return "53b73df79b80e8a9ac1f572270c19462";
  }

  static const char* value(const  ::AutoNav::circle_control_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0x53b73df79b80e8a9ULL;
  static const uint64_t static_value2 = 0xac1f572270c19462ULL;
};

template<class ContainerAllocator>
struct DataType< ::AutoNav::circle_control_<ContainerAllocator> > {
  static const char* value() 
  {
    return "AutoNav/circle_control";
  }

  static const char* value(const  ::AutoNav::circle_control_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::AutoNav::circle_control_<ContainerAllocator> > {
  static const char* value() 
  {
    return "float32 yaw\n\
\n\
float32 goalX\n\
float32 goalY\n\
\n\
float32 errorX\n\
float32 errorY\n\
\n\
float32 PerrorX\n\
float32 PerrorY\n\
\n\
float32 PvelX\n\
float32 PvelY\n\
\n\
float32 VerrX\n\
float32 VerrY\n\
float32 VerrA\n\
\n\
float32 CTgainP\n\
float32 CTgainD\n\
\n\
float32 ATgainP\n\
float32 ATgainI\n\
\n\
float32 ANGgainP\n\
float32 ANGgainD\n\
";
  }

  static const char* value(const  ::AutoNav::circle_control_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator> struct IsFixedSize< ::AutoNav::circle_control_<ContainerAllocator> > : public TrueType {};
} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::AutoNav::circle_control_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.yaw);
    stream.next(m.goalX);
    stream.next(m.goalY);
    stream.next(m.errorX);
    stream.next(m.errorY);
    stream.next(m.PerrorX);
    stream.next(m.PerrorY);
    stream.next(m.PvelX);
    stream.next(m.PvelY);
    stream.next(m.VerrX);
    stream.next(m.VerrY);
    stream.next(m.VerrA);
    stream.next(m.CTgainP);
    stream.next(m.CTgainD);
    stream.next(m.ATgainP);
    stream.next(m.ATgainI);
    stream.next(m.ANGgainP);
    stream.next(m.ANGgainD);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct circle_control_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::AutoNav::circle_control_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const  ::AutoNav::circle_control_<ContainerAllocator> & v) 
  {
    s << indent << "yaw: ";
    Printer<float>::stream(s, indent + "  ", v.yaw);
    s << indent << "goalX: ";
    Printer<float>::stream(s, indent + "  ", v.goalX);
    s << indent << "goalY: ";
    Printer<float>::stream(s, indent + "  ", v.goalY);
    s << indent << "errorX: ";
    Printer<float>::stream(s, indent + "  ", v.errorX);
    s << indent << "errorY: ";
    Printer<float>::stream(s, indent + "  ", v.errorY);
    s << indent << "PerrorX: ";
    Printer<float>::stream(s, indent + "  ", v.PerrorX);
    s << indent << "PerrorY: ";
    Printer<float>::stream(s, indent + "  ", v.PerrorY);
    s << indent << "PvelX: ";
    Printer<float>::stream(s, indent + "  ", v.PvelX);
    s << indent << "PvelY: ";
    Printer<float>::stream(s, indent + "  ", v.PvelY);
    s << indent << "VerrX: ";
    Printer<float>::stream(s, indent + "  ", v.VerrX);
    s << indent << "VerrY: ";
    Printer<float>::stream(s, indent + "  ", v.VerrY);
    s << indent << "VerrA: ";
    Printer<float>::stream(s, indent + "  ", v.VerrA);
    s << indent << "CTgainP: ";
    Printer<float>::stream(s, indent + "  ", v.CTgainP);
    s << indent << "CTgainD: ";
    Printer<float>::stream(s, indent + "  ", v.CTgainD);
    s << indent << "ATgainP: ";
    Printer<float>::stream(s, indent + "  ", v.ATgainP);
    s << indent << "ATgainI: ";
    Printer<float>::stream(s, indent + "  ", v.ATgainI);
    s << indent << "ANGgainP: ";
    Printer<float>::stream(s, indent + "  ", v.ANGgainP);
    s << indent << "ANGgainD: ";
    Printer<float>::stream(s, indent + "  ", v.ANGgainD);
  }
};


} // namespace message_operations
} // namespace ros

#endif // AUTONAV_MESSAGE_CIRCLE_CONTROL_H

